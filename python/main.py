# Static Text Objects --------------------------------------------------------

header_header = """
#ifndef __ETHERCAT_INFO_H
#define __ETHERCAT_INFO_H

/*
 * This file is automatically generated from the EtherCATInfo xml files.
 * Please refrain from modifying this file by hand.
 */

#include <stdlib.h> /* For `size_t` */
#include <stdint.h> /* For fixed sized integer definitions */

#define MAX_STRING_LEN 256
"""

header_footer = """
#endif /* __ETHERCAT_INFO_H */
"""

header_device_struct_defn = """
/**
 * Describes the device info and assigned device
 * identifier for the lookup operations
 */
struct ec_device {
    uint32_t db_index;
    uint32_t vendor_id;
    uint32_t product_code;
    uint32_t revision_no;
    char type[MAX_STRING_LEN];
};
"""

header_pdo_entry_info = """
/**
 * Describes the default direction
 * of transfer for the PDO entry
 */
typedef enum {
    UKN = 0,                    /** To avoid errors with default null values */
    TX  = 1,                    /** Transmit direction ( slave -> master )   */
    RX  = 2,                    /** Receive direction  ( slave <- master )   */
} pdo_dir;

/**
 * Describes the `BaseDataType`s allowed
 * in the PDO data TX/RX transfers
 */
typedef enum {
//  TYPE:  (BIT_SIZE): DESCRIPTION
    BDT_BOOL,     /** ( 1): Boolean value ; 0 == False, 1 == True */
    BDT_BIT,      /** ( 1): Bit value ; 0 == False, 1 == True     */
    BDT_BYTE,     /** ( 8): 1 Octet                               */
    BDT_WORD,     /** (16): 2 Octets                              */
    BDT_DWORD,    /** (32): 4 Octets                              */
    BDT_BIT1,     /** ( 1): Bit length value of size 1            */
    BDT_BIT2,     /** ( 2): Bit length value of size 2            */
    BDT_BIT3,     /** ( 3): Bit length value of size 3            */
    BDT_BIT4,     /** ( 4): Bit length value of size 4            */
    BDT_BIT5,     /** ( 5): Bit length value of size 5            */
    BDT_BIT6,     /** ( 6): Bit length value of size 6            */
    BDT_BIT7,     /** ( 7): Bit length value of size 7            */
    BDT_BIT8,     /** ( 8): Bit length value of size 8            */
    BDT_BITARR8,  /** ( 8): Array of 8 bits                       */
    BDT_BITARR16, /** (16): Array of 16 bits                      */
    BDT_BITARR32, /** (32): Array of 32 bits                      */
    BDT_SINT,     /** ( 8): Short Integer                         */
    BDT_INT,      /** (16): Integer                               */
    BDT_INT24,    /** (24): 24 Bit Integer                        */
    BDT_DINT,     /** (32): Double Integer                        */
    BDT_INT40,    /** (40): 40 Bit Integer                        */
    BDT_INT48,    /** (48): 48 Bit Integer                        */
    BDT_INT52,    /** (52): 52 Bit Integer                        */
    BDT_LINT,     /** (64): Long Integer                          */
    BDT_USINT,    /** ( 8): Unsigned Short Integer                */
    BDT_UINT,     /** (16): Unsigned Integer                      */
    BDT_UINT16,   /** (16): Unsigned 16 Bit Integer               */
    BDT_UINT24,   /** (24): Unsigned 24 Bit Integer               */
    BDT_UDINT,    /** (32): Unsigned Double Integer               */
    BDT_UINT40,   /** (40): Unsigned 40 Bit Integer               */
    BDT_UINT48,   /** (48): Unsigned 48 Bit Integer               */
    BDT_UINT52,   /** (52): Unsigned 52 Bit Integer               */
    BDT_ULINT,    /** (64): Unsigned Long Integer                 */
    BDT_REAL,     /** (32): Real Number / Floating Point          */
    BDT_LREAL,    /** (64): Real Number / Long Floating Point     */
    BDT_GUID,     /** (128): Global Unique Identifier             */
} base_data_t;

/**
 * Holds the extracted PDO information
 * from the XML device description
 */
struct pdo_entry_info {
    uint32_t    db_index;         /** The device identifier                 */
    uint16_t    index;            /** The CAN Address of the data           */
    uint8_t     subindex;         /** The CAN Sub-Index of the data         */
    uint8_t     bit_length;       /** The bit length of the data            */
    pdo_dir     direction;        /** The direction {Transmit | Receive}    */
    uint8_t     sync_manager;     /** The default Sync Manager for the data */
    size_t      name_idx;         /** The index into the PDO string list    */
    base_data_t data_type;        /** The index into the PDO string list    */
};

/**
 * Entries of the PDO entry description string
 */
struct pdo_string_entry {
    size_t index;                  /** The index of the string               */
    char   string[MAX_STRING_LEN]; /** The pdo description string            */
};

"""

test_c_main_txt = """
#include <stdio.h>
#include <assert.h>
#include "_test.h"
int main () {
    size_t dev_count = sizeof(ec_devices)/sizeof(struct ec_device);
    //size_t pdo_count = sizeof(pdo_entries)/sizeof(struct pdo_entry_info);
    // These are the actual counts of the objects minus the blank object
    // at the end and the 1 for indexing
    dev_count -= 2;

    struct ec_device *dev = ec_devices;
    for (unsigned int idx = 0; idx < dev_count; idx++, dev++) {}
    assert(dev_count == dev->db_index);
    return 0;
}
"""

# Class stubs for programmatic object creation -------------------------------
class Device(object):
    def __init__(self):
        self.typ = ""
        self.vendor_id = ""
        self.product_code = ""
        self.revision_no = ""
        self.serial_no = ""
        self.check_product_code = ""
        self.group_type = ""
        self.mailbox = ""
        self.dc = ""
        self.name = []
        self.url = []
        self.hide_type = []
        self.fmmu = []
        self.sm = []
        self.rx_pdo = []
        self.tx_pdo = []
    pass

class Eeprom(object):
    pass

class Dc(object):
    def __init__(self):
        self.op_mode = []
    pass

class DcOpMode(object):
    pass

class Fmmu(object):
    pass

class Sm (object):
    pass

class TxPdo(object):
    def __init__(self):
        self.fixed = ""
        self.sm = ""
        self.index = ""
        self.name = ""
        self.exclude = ""
        self.entry = []
    pass

class RxPdo(object):
    def __init__(self):
        self.fixed = ""
        self.sm = ""
        self.index = ""
        self.name = ""
        self.exclude = ""
        self.entry = []
    pass

class PdoEntry(object):
    def __init__(self):
        self.index = ""
        self.sub_index = ""
        self.bit_len = ""
        self.name = ""
        self.data_type = ""
    pass

class Mailbox(object):
    pass

# Utility functions ---------------------------------------------------------- 

# Returns a string text for the Locale Id codes.
# NOTE: These codes are based on the Microsoft Locale Id codes.
def parse_location_id(val):
    if val == "1033" or val == "3081" or val == "2057":
        return "EN"
    elif val == "1031" or val == "2055":
        return "DE"
    #elif val == "1036" or val == "3084":
    #    return "Fr"
    #elif val == "2052" or val == "3076":
    #    return "Zh"
    #elif val == "2052" or val == "3076":
    #    return "Zh"
    #elif val == "1041":
    #    return "Jp"
    # NOTE: Below are some other probably less used values, but can be added
    #       if such languages are encountered
    # 1041 -> Dutch
    # 1040 -> Italian
    # 1027 -> Catalan
    # 1044 or 2068 -> Norwegian
    # 2070 -> Portuguese
    # 1053 -> Swedish
    # 1034 -> Spanish
    # 1049 -> Russian
    else:
        return "Unknown"

# parses the xml form of hex numerals (#x0000)
# and returns a C compatible version  (0x0000)
def parse_hex(xml_hex):
    return xml_hex.replace('#', '0', 1)

# parses the data type value to add 'BDT_'
# to the beginning.
# This was added to help prevent datatype conflicts
def parse_bdt(bdt_string):
    return "BDT_{}".format(bdt_string)

# parser functions ----------------------------------------------------------- 

# The `parser_top_level` function takes the EtherCATInfo XML files and parses
# out the relevant device profile information
def parser_top_level(file_name, devices):
    import xml.etree.ElementTree as ET
    tree = ET.parse(file_name)
    root = tree.getroot()
    # `Device` (Optional 0..inf)
    for device in root.iter('Device'):
        dev = Device()
        # `Type` (Mandatory 1)
        #     Device identity incl. name, product code, revision no
        typ = device.find("Type")
        dev.typ = typ.text
        #     Vendor Specific product code
        dev.product_code = typ.get("ProductCode", "")
        #     Vendor Specific revision number
        dev.revision_no = typ.get("RevisionNo", "")
        #     All devies with the same combo of `ProductCode` && `RevisionNo`
        #     should write a serial number to `SerialNo`
        dev.serial_no = typ.get("SerialNo", "")
        #     Specifies if the product code should be equal to the eeprom value
        #     (default: "EQ"), or if it is not checked ("NONE")
        dev.check_product_code = typ.get("CheckProductCode", "EQ")
        # NOTE: Other `Type` values are currently ignored
        # `HideType` (Optional 0..inf)
        #     Contains revision numbers of devices which should not be 
        #     displayed in configuration tools...
        # NOTE: values `ProductCode` and `ProductRevision` are ignored
        for typ in device.findall("HideType"):
            dev.hide_type.append(typ.attrib.get("RevisionNo", ""))
        # `AlternativeType` (Optional 0..inf) (Vendor Specific)
            # `ProductCode` (Optional) (future use)
            # `RevisionNo`  (Optional) (future use)
        # `SubDevice` (Optional 0..inf)
        #     Used to display EtherCAT slaves built from more than one EtherCAT
        #     Slave Controller. 
            # `ProductCode` (Optional)
            # `RevisionNo` (Optional)
            # `PreviousDevice` (Optional)
            # `PreviousPortNo` (Optional)
        # `Name` (Mandatory 1..inf)
        #     Detailed name of the device
        for name in device.findall("Name"):
            lc_id_val = name.get("LcId", "")
            lc_id = parse_location_id(lc_id_val)
            dev.name.append((lc_id, name.text))
        # `Comment` (Optional 0..inf)
        # `URL` (Optional 0..inf)
        #    Url pointing to the vendor's homepage where the ESI may be downloaded
        for url in device.findall("URL"):
            lc_id_val = url.get("LcId", "")
            lc_id = parse_location_id(lc_id_val)
            dev.url.append((lc_id, url.text))
        # `Info` (Optional 0..1)
        #    Additional information about the device
        #info = device.find("Info")
        #    # `Mailbox`
        #        # `Timeout`
        #            # `RequestTimeout`
        #mbox_request_timeout = info.find("./Mailbox/Timeout/RequestTimeout")
        #if mbox_request_timeout is not None:
        #    print "MailboxRequestTimeout =", mbox_request_timeout.text
        #            # `ResponseTimeout`
        #mbox_response_timeout = info.find("./Mailbox/Timeout/ResponseTimeout")
        #if mbox_response_timeout is not None:
        #    print "MailboxResponseTimeout =", mbox_response_timeout.text
            # `Electrical`
            # `VendorSpecific`
            # `StateMachine`
                # `Timeout`
                    # `PreopTimeout`
                    # `SafeopOpTimeout`
                    # `BackToInitTimeout`
                    # `BackToSafeopTimeout`
        # `GroupType` (Mandatory 1)
        #     Reference to a group which this element should be assigned to.
        #     The reference is defined in the element `Groups`.
        dev.group_type = device.find("GroupType").text
        # `Profile` (Optional 0..inf)
        #     Description of the used profile and object dictionary including
        #     the data type definitions.
            # `ChannelInfo`
            # `Dictionary`
                # `DataTypes`
                    # `DataType`
                        # `Name`
                        # `BaseType` (Optional)
                        # `BitSize`
                        # `ArrayInfo` (Optional)
                            # `LBound`
                            # `Elements`
                        # `EnumInfo` (Optional)
                            # `Text`
                            # `Enum`
                        # `SubItem` (Optional)
                            # `SubIndex`
                            # `Name`
                            # `Type`
                            # `BitSize`
                            # `BitOffs`
                            # `Flags`
                                # `Access`
                                # `Category`
                                # `Backup`
                                # `Setting`
                    # `Object`
                        # `Index`
                        # `Name`
                        # `Type`
                        # `BitSize`
                        # `Info`
                            # `DefaultData`
                            # `SubItem`
                                # `Name`
                                # `Info`
                                    # `DefaultData`
                        # `Flags`
                            # `Access`
                            # `Category`
            # `DiagMessages`
                # `TextId`
                # `MessageText`
        # `Fmmu` (Optional 0..inf)
        #     Assigns FMMU to Sync-Manager; Definition of the FMMU usage.
        #     Allowed values:
        #         'Outputs'   -> used for RxPdo
        #         'Inputs'    -> used for TxPdo
        #         'MBoxState' -> used to poll the input Mailbox State (0x080D.0)
        # NOTE: Mandatory if more than one FMMU for the same direction is used
        #       to map data to non-constructive memory areas.
        # NOTE: Sm count starts at 0
        for fmmu in device.findall("Fmmu"):
            _fmmu = Fmmu()
            _fmmu.usage = fmmu.text
            dev.fmmu.append(_fmmu)
        # `Sm` (Optional 0..inf)
        #     Description of the Sync-Manager including start address and
        #     direction of transmission.
        #     Allowed values:
        #         'MBoxOut' -> Mailbox data (Master -> Slave)
        #         'MBoxIn'  -> Mailbox data (Slave  -> Master)
        #         'Outputs' -> Process data (Master -> Slave)
        #         'Inputs'  -> Process data (Slave  -> Master)
        #     The first Sync-Manager describes `SyncManager0` and then next
        #     `SyncManager1` and so on. If more than one Sync-Manager of the
        #     same direction and buffer mode are used the attribute Pdo@Su is
        #     mandatory.
        for sman in device.findall("Sm"):
            sm = Sm()
            dev.sm.append(sm)
            sm.typ = sman.text
            sm.min_size = sman.get("MinSize", "")
            sm.max_size = sman.get("MaxSize", "")
            # NOTE: Mandatory for Mailbox Sync-Manager
            #     Process Data Sync-Manager default length is based on the
            #     default PDO assignment in the Rx/Tx-Pdo entries.
            sm.default_size = sman.get("DefaultSize", "")
            # NOTE: If a Sync-Manager is configured for 3-buffer mode the
            #       occupied memory is 3x the length and should be considered
            #       in the calculation of the following Sync-Manager Address.
            sm.start_address = sman.get("StartAddress", "")
            sm.control_byte = sman.get("ControlByte", "")
            sm.enable = sman.get("Enable", "")
            #     if '1' then master should enable the Sync-Manager only in the
            #     operational state; if '0' the State machine is handled by host
            #     controller.
            # NOTE: True for devices with a digital I/O interface
            sm.op_only = sman.get("OpOnly", "")
        # `Su` (Optional 0..inf) (Perhaps mandatory, see above)
        #     Defines a timing context by defining different datagrams, possibly
        #     in different frames, which are identified by this string.
            # `SeparateSu` (Optional)
            # `SeparateFrame` (Optional)
            # `DependOnInputState` (Optional)
            # `FrameRepeatSupport` (Optional)
        # `RxPdo` (Optional 0..inf)
        #     Description of the output process data.
        for rxp in device.findall("RxPdo"):
            rx = RxPdo()
            rx.fixed = rxp.get("Fixed", "0")
            rx.sm = rxp.get("Sm", "-1")
            # NOTE: Skipping other RxPdo attributes
            # NOTE: RxPdo area : 0x1600 - 0x17FF
            rxp_index = rxp.find("Index")
            rxp_name = rxp.find("Name")
            rxp_exclude = rxp.find("Exclude")
            # `Index`
            if rxp_index is not None:
                rx.index = rxp_index.text
            # `Name`
            if rxp_name is not None:
                rx.name = rxp_name.text
            # `Exclude` (Optional)
            if rxp_exclude is not None:
                rx.exclude = rxp_exclude.text
            # `Entry`
            for item in rxp.findall("Entry"):
                ent = PdoEntry()
                ent_idx = item.find("Index")
                ent_subidx = item.find("SubIndex")
                ent_bitlen = item.find("BitLen")
                ent_name = item.find("Name")
                ent_datatype = item.find("DataType")
                # `Index`
                if ent_idx is not None:
                    ent.index = ent_idx.text
                # `SubIndex`
                if ent_subidx is not None:
                    ent.sub_index = ent_subidx.text
                # `BitLen`
                if ent_bitlen is not None:
                    ent.bit_len = ent_bitlen.text
                # `Name`
                if ent_name is not None:
                    ent.name = ent_name.text
                # `DataType`
                if ent_datatype is not None:
                    ent.data_type = ent_datatype.text
                ent.sm = rx.sm
                ent.direction = "RX"
                rx.entry.append(ent)
            dev.rx_pdo.append(rx)

        #     Description of the input process data
        for txp in device.findall("TxPdo"):
            tx = TxPdo()
            #    '0' -> Pdo Mapping can be changed
            #    '1' -> Pdo not configurable
            tx.fixed = txp.get("Fixed", "0")
            #    Default Sm for this PDO (included by default)
            tx.sm = txp.get("Sm", "-1")
            # NOTE: Skipping other RxPdo attributes
            # NOTE: TxPdo area : 0x1A00 - 0x1BFF
            txp_index = txp.find("Index")
            txp_name = txp.find("Name")
            txp_exclude = txp.find("Exclude")
            # `Index`
            if txp_index is not None:
                tx.index = txp_index.text
            # `Name`
            if txp_name is not None:
                tx.name = txp_name.text
            # `Exclude` (Optional)
            if txp_exclude is not None:
                tx.exclude = txp_exclude.text
            # `Entry`
            for item in txp.findall("Entry"):
                ent = PdoEntry()
                ent_idx = item.find("Index")
                ent_subidx = item.find("SubIndex")
                ent_bitlen = item.find("BitLen")
                ent_name = item.find("Name")
                ent_datatype = item.find("DataType")
                # `Index`
                if ent_idx is not None:
                    ent.index = ent_idx.text
                # `SubIndex`
                if ent_subidx is not None:
                    ent.sub_index = ent_subidx.text
                # `BitLen`
                if ent_bitlen is not None:
                    ent.bit_len = ent_bitlen.text
                # `Name`
                if ent_name is not None:
                    ent.name = ent_name.text
                # `DataType`
                if ent_datatype is not None:
                    ent.data_type = ent_datatype.text
                ent.sm = tx.sm
                ent.direction = "TX"
                tx.entry.append(ent)
            dev.tx_pdo.append(tx)
        # `Mailbox` (Optional 0..1)
        #     Description of available mailbox protocols
        mailbox = device.find("Mailbox")
        if mailbox is not None:
            # NOTE: if the object isn't present then it's not available in
            #       the slave device
            dev.mailbox = Mailbox()
            # `AoE`
            mbox_aoe = mailbox.find("AoE")
            if mbox_aoe is not None:
                dev.mailbox.aoe = mbox_aoe.attrib
            # `CoE`
            mbox_coe = mailbox.find("CoE")
            if mbox_coe is not None:
                dev.mailbox.coe = mbox_coe.attrib
            # `EoE`
            mbox_eoe = mailbox.find("EoE")
            if mbox_eoe is not None:
                dev.mailbox.eoe = mbox_eoe.attrib
            # `FoE`
            mbox_foe = mailbox.find("FoE")
            if mbox_foe is not None:
                dev.mailbox.foe = mbox_foe.attrib
            # `SoE`
            mbox_soe = mailbox.find("SoE")
            if mbox_soe is not None:
                dev.mailbox.soe = mbox_soe.attrib
            # `VoE`
            mbox_voe = mailbox.find("VoE")
            if mbox_voe is not None:
                dev.mailbox.voe = mbox_voe.attrib
        # `Dc` (Optional 0..1)
        #     Description of the following synchronization modes if available:
        #     {Freerun | Synchronous w/ Sm Event | Distributed Clocks}
        dc = device.find("Dc")
        if dc is not None:
            dev.dc = Dc()
            # `OpMode` (Optional 0..inf)
            for item in dc.findall("OpMode"):
                opmode = DcOpMode()
                dc_name = item.find("Name")
                dc_desc = item.find("Desc")
                dc_assign = item.find("AssignActivate")
                dc_cyc_syn0 = item.find("CycleTimeSync0")
                dc_sft_snc0 = item.find("ShiftTimeSync0")
                dc_cyc_syn1 = item.find("CycleTimeSync1")
                dc_sft_snc1 = item.find("ShiftTimeSync1")
                # `Name`
                if dc_name is not None:
                    opmode.name = dc_name.text
                # `Desc`
                if dc_desc is not None:
                    opmode.desc = dc_desc.text
                # `AssignActivate`
                if dc_assign is not None:
                    opmode.assign_activate = dc_assign.text
                # `CycleTimeSync0`
                if dc_cyc_syn0 is not None:
                    opmode.cycle_time_sync_0 = dc_cyc_syn0.text
                # `ShiftTimeSync0`
                if dc_sft_snc0 is not None:
                    opmode.shift_time_sync_0 = dc_sft_snc0.text
                # `CycleTimeSync1`
                if dc_cyc_syn1 is not None:
                    opmode.cycle_time_sync_1 = dc_cyc_syn1.text
                # `ShiftTimeSync1`
                if dc_sft_snc1 is not None:
                    opmode.shift_time_sync_1 = dc_sft_snc1.text
                dev.dc.op_mode.append(opmode)
        # `Slots` (Optional 0..??)
        #     Defines the combination of possibilities of the modules which may
        #     be used if the device supports Modular Device Profiles (ETG.5001)
        #     The modules are defined in the `Modules` element
        # `ESC` (Optional 0..??)
        #     Initialization values of the EtherCAT Slave Controller Watchdog 
        #     registers
        # `Eeprom` (Optional 0..1)
            # `AssignToPdi` : '0' -> access assigned to PDI during Init -> PreOp
            #               : '1' -> Eeprom PDI access in all states except Init
        # NOTE: Either `Eeprom@Data` is present or the other three are present.
        # NOTE: EEPROM data format is little-endian
        if device.find("Eeprom") is not None:
            dev.eeprom = Eeprom()
            eeprom_data = device.find("./Eeprom/Data")
            eeprom_bytesize = device.find("./Eeprom/ByteSize")
            eeprom_configdata = device.find("./Eeprom/ConfigData")
            eeprom_bootstrap = device.find("./Eeprom/BootStrap")
            # `Data`
            #     Complete EEPROM data; length is implicit
            if eeprom_data is not None:
                dev.eeprom.data = eeprom_data.text
            # `ByteSize`
            if eeprom_bytesize is not None:
                dev.eeprom.byte_size = eeprom_bytesize.text
            # `ConfigData`
            if eeprom_configdata is not None:
                dev.eeprom.config_data = eeprom_configdata.text
            # `BootStrap`
            if eeprom_bootstrap is not None:
                dev.eeprom.bootstrap = eeprom_bootstrap.text
        #NOTE: There are three possibilities for images and if there is an
        #      image then only one of these can be chosen
        #     The hex binary data of a BMP file with dimensions of 16x14 pixels
        #     which may be shown by config tool.
        #NOTE: The color 0xFF00FF is transparent.
            # `Image16x14` (Optional 0..1)
            # `ImageFile16x14` (Optional 0..1)
            # `ImageData16x14` (Optional 0..1)
        # `VendorSpecific`
        #     Vendor Specific elements of `DeviceType`
        # Add our device to the list of devices
        devices.append(dev)

# Output Functions ----------------------------------------------------------- 

# This is a test function to print out the c_file to the console for
# development. This may also be used for piping into an output file.
def gen_c_header(devices):
    output_lines = []
    # actual lines we're storing. We need to save them before hand to make sure
    # that the Id we assign to the device is consistent throughout the struts.
    bk_vendor_id = "0x00000002" # TODO: This should be read from the file
    device_lines = []
    fmmu_lines = []
    sm_lines = []
    rx_lines = []
    tx_lines = []
    pdo_entry_info = []
    pdo_string_map = dict()
    pdo_string_lst = []
    pdo_string_idx = 0
    entry_str_idx = 0
    idx = 0
    for dev in devices:
        pc  = parse_hex(dev.product_code)
        rev = parse_hex(dev.revision_no)
        # -- DEVICE ENTRIES
        # if the device doesn't have a product code / revision number we'll
        # skip it as these won't be able to be read from the driver anyways
        if pc == "":
            continue
        # create the actual device data entry
        fstr = '{{ {:>4}, {:>10}, {:>10}, {:>10}, "{}" }},\n'
        device_lines.append(fstr.format(idx, bk_vendor_id, pc, rev, dev.typ))
        # -- /DEVICE ENTRIES

        # -- PDO ENTRIES
        pdos = []
        # TxPdo entries
        for pdo in dev.tx_pdo:
            pdos.append(pdo)
        # RxPdo entries
        for pdo in dev.rx_pdo:
            pdos.append(pdo)
        # create the output
        for pdo in pdos:
            for entry in pdo.entry:
                # skip 'empty' addresses or indexes
                if entry.index == "#x0" or entry.index == "0" or entry.sub_index == "":
                    continue
                # skip entries without a defined Sync-Manager
                if entry.sm == "-1":
                    continue
                # calculate the string db entry
                if entry.name not in pdo_string_map:
                    pdo_string_map[entry.name] = pdo_string_idx;
                    entry_str_idx = pdo_string_idx
                    pdo_string_idx = pdo_string_idx + 1
                else:
                    entry_str_idx = pdo_string_map[entry.name]
                # add the pdo entry to the list
                pdo_entry_info.append('{{ {:>4}, {:>6}, {:>2}, {:>3}, {:2}, {:>2}, {:>2}, {} }},'.format(
                    str(idx),
                    parse_hex(entry.index),
                    parse_hex(entry.sub_index),
                    entry.bit_len,
                    entry.direction,
                    entry.sm,
                    entry_str_idx,
                    parse_bdt(entry.data_type)))
        # -- /PDO ENTRIES
        #
        idx += 1
    # Collect the string db entries
    string_db = dict()
    for (k, v) in pdo_string_map.iteritems():
        if not string_db.has_key(v):
            string_db[v] = k
    for (k, v) in string_db.iteritems():
        pdo_string_lst.append('{{ {}, "{}" }},'.format(k, v))
    # -- WRITE OUT DATA
    # HEADER
    output_lines.append(header_header)
    # STRUCTS
    output_lines.append(header_device_struct_defn)
    output_lines.append(header_pdo_entry_info)
    # DEVICES
    output_lines.append("""struct ec_device ec_devices[] = {\n""")
    output_lines.append("""/* {db_index, vendor_id, prod_code, rev_num, type_str} */\n""")
    for line in device_lines:
        output_lines.append("    " + line)
    output_lines.append("""    {}\n};\n\n""")
    # PDOs
    output_lines.append("""struct pdo_entry_info pdo_entries[] = {\n""")
    output_lines.append("""/* {db_idx, idx, sub-idx, bit_len, dir, SM, name_idx} */""")
    for line in pdo_entry_info:
        output_lines.append("\n    " + line)
    output_lines.append("""\n    {}\n};\n\n""")
    # PDO -> String db
    output_lines.append("""struct pdo_string_entry pdo_string_db[] = {\n""")
    output_lines.append("""/* {name_idx, pdo_description_string} */""")
    for line in pdo_string_lst:
        output_lines.append("\n    " + line)
    output_lines.append("""\n    {}\n};\n""")
    # FOOTER
    output_lines.append(header_footer)
    return output_lines

# Test Functions ------------------------------------------------------------- 

def test_header(out_text):
    from subprocess import check_output
    # Create the C file
    with open("./_test.c", "w+") as c_file:
        c_file.write(test_c_main_txt)
    # Create the Header file
    with open("./_test.h", "w+") as h_file:
        h_file.writelines(out_text)
    # Run the complier & read the output
    output = check_output(["gcc", "-std=c99", "_test.c"])
    # compare the output
    return

def test_program():
    from subprocess import check_output
    # Run the complier & read the output
    output = check_output(["gcc", "-std=c99","-Wall", "_test.c"])
    # compare the output
    return

# Main Functions ------------------------------------------------------------- 

def gen_all_file(devices):
    import glob
    # find our files
    file_paths = glob.glob("./Beckhoff_EtherCAT_XML/*.xml")
    # run the parser
    for path in file_paths:
        parser_top_level(path, devices)
    # run the generator
    out = gen_c_header(devices)
    return out

def gen_test_file(devices):
    parser_top_level("./file.xml", devices)
    parser_top_level("./file1.xml", devices)
    # run the generator
    out = gen_c_header(devices)
    return out

if __name__ == "__main__":
    devices = []
    #  -- Generation functions: choose _one_
    output = gen_all_file(devices)
    #output = gen_test_file(devices)
    #output = []
    #  --
    # print out the number of devices found
    print "Generated configuration for", len(devices), "devices"
    # Test the file to see if it can compile
    test_header(output)
